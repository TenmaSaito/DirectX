//================================================================================================================
//
// DirectXの入力処理 [input.cpp]
// Author : TENMA
//
//================================================================================================================
#include "input.h"

// マクロ定義
#define NUM_KEY_MAX			(256)			// キーの最大数
#define NUM_MOUSE_MAX		(3)				// ボタンの最大数
#define THUMB_SLOW			(12)				// GetJoyThumbSlowでの遅延する数

// グローバル変数
LPDIRECTINPUT8 g_pInput = NULL;					// DirectInputオブジェクトのポインタ
LPDIRECTINPUTDEVICE8 g_pDevKeyboard = NULL;		// 入力デバイス(キーボード)へのポインタ
BYTE g_aKeyState[NUM_KEY_MAX];					// キーボードのプレス情報
BYTE g_aKeyStateTrigger[NUM_KEY_MAX];			// キーボードのトリガー情報
BYTE g_aKeyStateRelease[NUM_KEY_MAX];			// キーボードのリリース処理
int g_nCounterRepeat[NUM_KEY_MAX] = {};			// リピートのカウント

XINPUT_STATE g_joykeyState;						// ジョイパッドのプレス情報
XINPUT_STATE g_joykeyStateTrigger;				// ジョイパッドのトリガー情報
XINPUT_STATE g_joykeyStateRelease;				// ジョイパッドのリリース情報
int g_nCounterRepeatJoypad[JOYKEY_MAX] = {};	// ジョイパッドのリピートのカウント
int g_nCounterJoyThumb[JOYTHUMB_MAX] = {};		// ジョイパッドのスティックの遅延カウント
XINPUT_VIBRATION g_joyVibration;				// ジョイパッドのバイブレーション情報

LPDIRECTINPUTDEVICE8 g_pDevMouse = NULL;		// 入力デバイス(マウス)へのポインタ

DIMOUSESTATE g_CurrentMouseState;				// マウスの入力情報
DIMOUSESTATE g_PrevMouseState;					// マウスの過去の入力情報
BYTE g_aMouseState[NUM_MOUSE_MAX];				// マウスのプレス情報
BYTE g_aMouseStateRelease[NUM_MOUSE_MAX];		// マウスのリリース情報
POINT g_mousePos = {};							// マウスの位置

HWND g_InputhWnd = NULL;						// 座標変換に使用するウィンドウのハンドル

//================================================================================================================
//キーボードの初期化処理
//================================================================================================================
HRESULT InitKeyboard(HINSTANCE hInstance, HWND hWnd)
{
	// DirectInputオブジェクトの生成
	if (FAILED(DirectInput8Create(hInstance,
								  DIRECTINPUT_VERSION,
								  IID_IDirectInput8,
								  (void**)&g_pInput,
								  NULL)))
	{
		return E_FAIL;
	}

	// 入力デバイス(キーボード)の生成
	if (FAILED(g_pInput->CreateDevice(GUID_SysKeyboard,
									  &g_pDevKeyboard,
									  NULL)))
	{
		return E_FAIL;
	}

	// データフォーマットを設定
	if (FAILED(g_pDevKeyboard->SetDataFormat(&c_dfDIKeyboard)))
	{
		return E_FAIL;
	}

	// 協調モードを設定
	if (FAILED(g_pDevKeyboard->SetCooperativeLevel(hWnd,
												   (DISCL_FOREGROUND | DISCL_NONEXCLUSIVE))))
	{
		return E_FAIL;
	}

	//キーボードへのアクセス権を獲得
	g_pDevKeyboard->Acquire();

	// ウィンドウハンドルを保存
	g_InputhWnd = hWnd;

	return S_OK;
}

//================================================================================================================
//キーボードの終了処理
//================================================================================================================
void UninitKeyboard(void)
{
	// 入力デバイス(キーボード)の破棄
	if (g_pDevKeyboard != NULL)
	{
		g_pDevKeyboard->Unacquire();
		g_pDevKeyboard->Release();
		g_pDevKeyboard = NULL;
	}

	// DirectInputオブジェクトの破棄
	if (g_pInput != NULL)
	{
		g_pInput->Release();
		g_pInput = NULL;
	}
}

//================================================================================================================
//キーボードの更新処理
//================================================================================================================
void UpdateKeyboard(void)
{
	BYTE aKeyState[NUM_KEY_MAX];			// キーボードの入力情報
	int nCntKey;

	// 入力デバイスからデータを取得
	if (SUCCEEDED(g_pDevKeyboard->GetDeviceState(sizeof(aKeyState), &aKeyState[0])))
	{
		for (nCntKey = 0; nCntKey < NUM_KEY_MAX; nCntKey++)
		{
			g_aKeyStateRelease[nCntKey] = (g_aKeyState[nCntKey] & (g_aKeyState[nCntKey] ^ aKeyState[nCntKey]));			// キーボードのリリース情報を保存
			g_aKeyStateTrigger[nCntKey] = ((aKeyState[nCntKey] ^ g_aKeyState[nCntKey]) & aKeyState[nCntKey]);			// キーボードのトリガー情報を保存
			if (g_aKeyState[nCntKey] != aKeyState[nCntKey])
			{
				g_nCounterRepeat[nCntKey] = 0;
			}
			g_aKeyState[nCntKey] = aKeyState[nCntKey];																	// キーボードのプレス情報を保存
		}			
	}
	else
	{
		g_pDevKeyboard->Acquire();			// キーボードへのアクセス権を取得
	}
}                                              

//================================================================================================================
// キーボードのプレス情報を取得
//================================================================================================================
bool GetKeyboardPress(int nKey)
{
	// 3項演算子
	return (g_aKeyState[nKey] & 0x80) ? true : false;
}

//================================================================================================================
// キーボードのトリガー情報を取得
//================================================================================================================
bool GetKeyboardTrigger(int nKey)
{
	return (g_aKeyStateTrigger[nKey] & 0x80) ? true : false;
}

//================================================================================================================
// キーボードのリリース情報を取得
//================================================================================================================
bool GetKeyboardRelease(int nKey)
{
	return (g_aKeyStateRelease[nKey] & 0x80) ? true : false;
}

//================================================================================================================
// キーボードのリピート情報を取得
//================================================================================================================
bool GetKeyboardRepeat(int nKey)
{
	g_nCounterRepeat[nKey]++;
	if (g_nCounterRepeat[nKey] < 30)
	{
		return (g_aKeyStateTrigger[nKey] & 0x80) ? true : false;
	}
	else
	{
		return (g_aKeyState[nKey] & 0x80) ? true : false;
	}
}

//================================================================================================================
// ジョイパッドの初期化処理
//================================================================================================================
HRESULT InitJoypad(void)
{
	// メモリのクリア
	memset(&g_joykeyState, 0, sizeof(XINPUT_STATE));

	memset(&g_joyVibration, 0, sizeof(XINPUT_VIBRATION));

	// XInputのステート設定(有効)
	XInputEnable(true);

	return S_OK;
}

//================================================================================================================
// ジョイパッドの終了処理
//================================================================================================================
void UninitJoypad(void)
{
	// XInputのステート設定(無効)
	XInputEnable(false);
}

//================================================================================================================
// ジョイパッドの更新処理
//================================================================================================================
void UpdateJoypad(void)
{
	XINPUT_STATE joykeyState;			// 入力情報

	// ジョイパッドの状態を取得
	if (XInputGetState(0, &joykeyState) == ERROR_SUCCESS)
	{
		if (g_joykeyState.Gamepad.sThumbLX <= 100.0f && g_joykeyState.Gamepad.sThumbLX >= -100.0f)
		{
			g_nCounterJoyThumb[JOYTHUMB_LX_UP] = 0;
			g_nCounterJoyThumb[JOYTHUMB_LX_DOWN] = 0;
		}

		if (g_joykeyState.Gamepad.sThumbLY <= 100.0f && g_joykeyState.Gamepad.sThumbLY >= -100.0f)
		{
			g_nCounterJoyThumb[JOYTHUMB_LY_UP] = 0;
			g_nCounterJoyThumb[JOYTHUMB_LY_DOWN] = 0;
		}

		if (g_joykeyState.Gamepad.sThumbRX <= 100.0f && g_joykeyState.Gamepad.sThumbRX >= -100.0f)
		{
			g_nCounterJoyThumb[JOYTHUMB_RX_UP] = 0;
			g_nCounterJoyThumb[JOYTHUMB_RX_DOWN] = 0;
		}

		if (g_joykeyState.Gamepad.sThumbRY <= 100.0f && g_joykeyState.Gamepad.sThumbRY >= -100.0f)
		{
			g_nCounterJoyThumb[JOYTHUMB_RY_UP] = 0;
			g_nCounterJoyThumb[JOYTHUMB_RY_DOWN] = 0;
		}

		g_joykeyStateTrigger.Gamepad.wButtons = ((joykeyState.Gamepad.wButtons ^ g_joykeyState.Gamepad.wButtons) & joykeyState.Gamepad.wButtons);
		g_joykeyStateRelease.Gamepad.wButtons = (g_joykeyState.Gamepad.wButtons & (g_joykeyState.Gamepad.wButtons ^ joykeyState.Gamepad.wButtons));
		g_joykeyState = joykeyState;	// プレス情報を保存
		
		for (int nCntJoykey = 0; nCntJoykey < JOYKEY_MAX; nCntJoykey++)
		{
			if ((g_joykeyState.Gamepad.wButtons & (0x01 << nCntJoykey)) == false)
			{
				g_nCounterRepeatJoypad[nCntJoykey] = 0;
			}
		}
	}
}

//================================================================================================================
// ジョイパッドのプレス情報を取得
//================================================================================================================
bool GetJoypadPress(JOYKEY Key)
{
	return (g_joykeyState.Gamepad.wButtons & (0x01 << Key)) ? true : false;
}

//================================================================================================================
// ジョイパッドのトリガー情報を取得
//================================================================================================================
bool GetJoypadTrigger(JOYKEY Key)
{
	return (g_joykeyStateTrigger.Gamepad.wButtons & (0x01 << Key)) ? true : false;
}

//================================================================================================================
// ジョイパッドのリリース情報を取得
//================================================================================================================
bool GetJoypadRelease(JOYKEY Key)
{
	return (g_joykeyStateRelease.Gamepad.wButtons & (0x01 << Key)) ? true : false;
}

//================================================================================================================
// ジョイパッドのリピート情報を取得
//================================================================================================================
bool GetJoypadRepeat(JOYKEY Key)
{
	g_nCounterRepeatJoypad[Key]++;
	if (g_nCounterRepeatJoypad[Key] <= 30)
	{
		return (g_joykeyStateTrigger.Gamepad.wButtons & (0x01 << Key)) ? true : false;
	}
	else
	{
		return (g_joykeyState.Gamepad.wButtons & (0x01 << Key)) ? true : false;
	}
}

//================================================================================================================
// ジョイパッドのバイブレーションのポインタを取得
//================================================================================================================
XINPUT_VIBRATION *GetJoyVibration(void)
{
	return &g_joyVibration;
}

//================================================================================================================
// ジョイパッドのポインタを取得
//================================================================================================================
XINPUT_STATE *GetJoypadState(void)
{
	return &g_joykeyState;
}

//================================================================================================================
// ジョイパッドの左スティック[X方向]の判定
//================================================================================================================
bool GetJoyThumbLXState(void)
{
	return (g_joykeyState.Gamepad.sThumbLX != 0) ? true : false;
}

//================================================================================================================
// ジョイパッドの左スティック[Y方向]の判定
//================================================================================================================
bool GetJoyThumbLYState(void)
{
	return (g_joykeyState.Gamepad.sThumbLY != 0) ? true : false;
}

//================================================================================================================
// ジョイパッドの右スティック[X方向]の判定
//================================================================================================================
bool GetJoyThumbRXState(void)
{
	return (g_joykeyState.Gamepad.sThumbRX != 0) ? true : false;
}

//================================================================================================================
// ジョイパッドの右スティック[Y方向]の判定
//================================================================================================================
bool GetJoyThumbRYState(void)
{
	return (g_joykeyState.Gamepad.sThumbRY != 0) ? true : false;
}

//================================================================================================================
// ジョイパッドのスティックの入力遅延
//================================================================================================================
bool GetJoyThumbSlow(JOYTHUMB Thumb)
{
	g_nCounterJoyThumb[Thumb]++;

	switch (Thumb)
	{
	case JOYTHUMB_LX_UP:
		if (g_joykeyState.Gamepad.sThumbLX > 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_LX_DOWN:
		if (g_joykeyState.Gamepad.sThumbLX < 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_LY_UP:
		if (g_joykeyState.Gamepad.sThumbLY > 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_LY_DOWN:
		if (g_joykeyState.Gamepad.sThumbLY < 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_RX_UP:
		if (g_joykeyState.Gamepad.sThumbRX > 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_RX_DOWN:
		if (g_joykeyState.Gamepad.sThumbRX < 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_RY_UP:
		if (g_joykeyState.Gamepad.sThumbRY > 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;

	case JOYTHUMB_RY_DOWN:
		if (g_joykeyState.Gamepad.sThumbRY < 0
			&& (g_nCounterJoyThumb[Thumb] % THUMB_SLOW) == 0)
		{
			return true;
		}
		else
		{
			return false;
		}

		break;
	}
}

//================================================================================================================
// マウスの初期化処理
//================================================================================================================
HRESULT InitMouse(HWND hWnd)
{
	// 入力デバイス(マウス)の生成
	g_pInput->CreateDevice(
		GUID_SysMouse,
		&g_pDevMouse,
		NULL
	);

	// データフォーマットを設定
	if (FAILED(g_pDevMouse->SetDataFormat(&c_dfDIMouse)))
	{
		return E_FAIL;
	}

	// 協調モードを設定
	if (FAILED(g_pDevMouse->SetCooperativeLevel(hWnd,
		(DISCL_FOREGROUND | DISCL_NONEXCLUSIVE))))
	{
		return E_FAIL;
	}

	// マウスへのアクセス権を獲得
	g_pDevMouse->Acquire();

	return S_OK;
}

//================================================================================================================
// マウスの終了処理
//================================================================================================================
void UninitMouse(void)
{
	// 入力デバイス(マウス)の破棄
	if (g_pDevMouse != NULL)
	{
		g_pDevMouse->Unacquire();
		g_pDevMouse->Release();
		g_pDevMouse = NULL;
	}
}

//================================================================================================================
// マウスの更新処理
//================================================================================================================
void UpdateMouse(void)
{
	BYTE aMouseState[NUM_MOUSE_MAX];			// マウスの入力情報

	// 更新前に過去の入力情報(マウス)を保存
	g_PrevMouseState = g_CurrentMouseState;

	// 現在のマウスの入力情報を取得
	if (SUCCEEDED(g_pDevMouse->GetDeviceState(sizeof(DIMOUSESTATE), &g_CurrentMouseState)))
	{
		for (int nCntMouse = 0; nCntMouse < NUM_MOUSE_MAX; nCntMouse++)
		{
			aMouseState[nCntMouse] = g_CurrentMouseState.rgbButtons[nCntMouse];

			g_aMouseStateRelease[nCntMouse] = (g_aMouseState[nCntMouse] & (g_aMouseState[nCntMouse] ^ aMouseState[nCntMouse]));
			g_aMouseState[nCntMouse] = aMouseState[nCntMouse];
		}
	}
	else
	{
		g_pDevMouse->Acquire();			// マウスへのアクセス権を取得
	}
}

//================================================================================================================
// マウスのプレス情報を取得
//================================================================================================================
bool GetMousePress(int nButton)
{
	return (g_aMouseState[nButton] & 0x80) ? true : false;
}

//================================================================================================================
// マウスのリリース情報を取得
//================================================================================================================
bool GetMouseRelease(int nButton)
{
	return (g_aMouseStateRelease[nButton] & 0x80) ? true : false;
}

//================================================================================================================
// マウスの位置情報を取得
//================================================================================================================
POINT GetMousePos(void)
{
	POINT mousePos;

	// マウスの位置を取得
	if (GetCursorPos(&mousePos) != TRUE)
	{// 取得失敗
		g_pDevMouse->Acquire();			// マウスへのアクセス権を取得
	}
	else
	{// 取得成功
		// 取得した座標をウィンドウ内の座標に変換
		ScreenToClient(g_InputhWnd, &mousePos);
		g_mousePos = mousePos;			// 現在の位置を保存
	}

	return g_mousePos;
}